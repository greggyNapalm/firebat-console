#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
firebat.console
~~~~~~~~~~~~~~~

Helper script for Phantom load tool.
    * generate config files and input data.
    * runs test.
    * aggregate result data.
"""

import os
import sys
#from datetime import date, datetime
import datetime
import argparse
import logging
import getpass
import itertools
#import multiprocessing
import commands
from progressbar import Bar, ProgressBar, Percentage, ETA

import yaml
import simplejson as json

from firebat.console.conf import make_conf, get_defaults
from firebat.console.stepper import parse_ammo, process_load_schema,\
fire_duration
from firebat.console.exceptions import StepperAmmoFormat, StepperSchemaFormat


def exit_err(msg):
    logger = logging.getLogger('firebat.console')
    if isinstance(msg, str):
        msg = [msg, ]
    for m in msg:
        logger.error(m)
    if not logger.handlers:
        sys.stderr.write(msg)
    sys.exit(1)


def validate_dict(d, req):
    present_keys = d.keys()
    diff = [val for val in req if val not in present_keys]
    if len(diff) != 0:
        raise ValueError('You missed required options in conf: %s' % diff)


def __build_path(orig_wd, config, fire, time):
    test_path = orig_wd + '/'
    test_path += config['title']['task'] + '_'
    test_path += getpass.getuser() + '_'
    test_path += time.strftime('%Y%m%d-%H%M%S') + '/'
    test_path += fire['name']
    return test_path


def start_daemon(fire):
    pid_file = '/var/run/fire_%s.pid' % int(time.time())
    executable = 'daemon_fire'
    opts = {
        'owner': 'Gregory Komissarov'
    }
    opts_str = json.dumps(opts) 
    cmd = 'start-stop-daemon --start --quiet'
    cmd += '--pidfile %s' % pid_file
    cmd += '--chdir %s' % fire['wd']
    cmd += '--exec %s -- %s' % (executable, opts_str)

    status, text = commands.getstatusoutput(cmd)
    print '---> DAEMON:\n %s\n%s' % (status, text)
    return status


def main():
    #d
    import pprint
    pp = pprint.PrettyPrinter(indent=4)
    #d
    defaults = get_defaults()
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--config', nargs=1, action='store',
                    dest='config_file', default='./fire.yaml',
                    help='path to configuration file',)

    parser.add_argument('-a', '--ammo', action='store',
                    dest='ammo_file', default=None,
                    help='path to ammo file',)

    parser.add_argument('-o', '--only-prepare-stpd', action='store',
                    dest='stpd_ammo_only', default=False,
                    help='Only generate ammo stpd and exit',)

    parser.add_argument('--debug', action="store_const", const=True,
            help='Whether to show debug msg in STDOUT', dest='debug')

    parser.add_argument('--version', action='version',
                    version='%(prog)s 0.0.1')
    args = parser.parse_args()

    logger = logging.getLogger('firebat.console')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    if args.debug:
        ch.setLevel(logging.DEBUG)
    else:
        ch.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s  %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    try:
        with open(args.config_file, 'r') as conf_fh:
            config = yaml.load(conf_fh)
    except IOError, e:
        exit_err('Could not read "%s": %s\n' % (args.config_file, e))
    except yaml.scanner.ScannerError, e:
        exit_err('Could not parse config file: %s\n%s' % (args.config_file, e))

    try:
        validate_dict(config['title'], defaults['title_required_keys'])
    except ValueError, e:
        exit_err('Error in parsing fire conf:\n%s' % e)

    now = datetime.datetime.now()
    ammo_cache = {}
    orig_wd = os.getcwd()
    ammo_from_arg = False
    for idx, f_orig in enumerate(config['fire']):
        f = defaults['fire_conf']
        f.update(f_orig)
        try:
            validate_dict(f, defaults['fire_required_keys'])
        except ValueError, e:
            exit_err('Error in parsing fire conf:\n%s' % e)
        config['fire'][idx] = f

        # get absolute ammo path before chdir
        if not ammo_from_arg:
            if args.ammo_file:
                ammo_from_arg = os.path.abspath(args.ammo_file)
                ammo_path = ammo_from_arg
            else:
                ammo_path = f['input_file']

        pbar_max = fire_duration(f)
        widgets = [Percentage(), Bar(), ETA(),]
        pbar = ProgressBar(widgets=widgets, maxval=pbar_max).start()
        job_path = __build_path(orig_wd, config, f, now)
        config['fire'][idx]['wd'] = job_path
        os.makedirs(job_path)
        os.chdir(job_path)

        with open('phantom.conf', 'w+') as cfg_fh:
            cfg_fh.write(make_conf(f))

        logger.info('Processing fire: %s' % f['name'])
        logger.info('Ammo file: %s' % ammo_path)
        logger.info('Load schema: %s' % f['load'])
        stpd_start = datetime.datetime.now()
        with open(ammo_path, 'r') as ammo_fh,\
            open('ammo.stpd', 'w+') as stpd_fh:
            f_path = os.path.abspath(ammo_fh.name)
            if f['cache_ammo']:
                ammo_cache[f_path] = {'chunks': [], }
            ammos = parse_ammo(ammo_fh)
            offset = f.get('offset', 0)
            for schema in f['load']:
                for tick in process_load_schema(schema, offset):
                    try:
                        try:
                            m_line, chunk = ammo_cache[f_path]['cycle'].next()
                            #sys.stdout.write('-->Cache, baybe!<--')
                        except KeyError:
                            m_line, chunk = ammos.next()
                            if f_path in ammo_cache:
                                ammo_cache[f_path]['chunks'].append(\
                                        (m_line, chunk))
                    except StopIteration:
                        # chunks in ammo file run out
                        if f['loop_ammo']:
                            # need to restart requests chunks generation or
                            # enable cashe if it present.
                            if f_path in ammo_cache:
                                if not 'cycle' in ammo_cache[f_path]:
                                    ammo_cache[f_path]['cycle'] =\
                                    itertools.cycle(ammo_cache[f_path]['chunks'])
                            else:
                                ammo_fh.seek(0)
                                ammos = parse_ammo(ammo_fh)
                                m_line, chunk = ammos.next()
                        else:
                            stpd_fh.write('0')
                            msg = [
                                'Not enough requests in ammo file' +
                                ' to cover load schema.',
                                'File: %s' % f['input_file'],
                                'Schema: %s' % schema,
                            ]
                            exit_err(msg)
                    req_stpd = m_line % tick + chunk + '\n'
                    stpd_fh.write(req_stpd)
                    pbar.update(tick)
                offset = tick  # use last time tick as next load schema offset
            stpd_fh.write('0')  # close stpd file according format
        pbar.finish()
        stpd_stop = datetime.datetime.now()
        stpd_job_dur = stpd_stop - stpd_start
        logger.info('ammo job takes: %s\n' % stpd_job_dur)
    logger.info('stpd generation finished.')

    if args.stpd_ammo_only:
        sys.exit(0)
    # ammo stpd and configs are ready, let's call launcher
    for f in config['fire']:
        start_daemon(f)
        #os.chdir(f['wd'])
        #start-stop-daemon --start --quiet --pidfile /var/run/$NAME.pid 
        #        >         --exec $DAEMON -- $DAEMON_OPTS
        ##pp.pprint(f)

        #d = multiprocessing.Process(name='daemon', target=run_supervisor)
        #d.daemon = True
        #d.start()

        #run_supervisor()


if __name__ == '__main__':
    main()
